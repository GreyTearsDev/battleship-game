{"version":3,"file":"app.bundle.js","mappings":";;;;;AAAa;;AAEb;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,aAAa,cAAc;AAC3B;AACO;AACP;AACA,uBAAuB,SAAS,eAAe,IAAI,eAAe,IAAI;AACtE;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACO;AACP,sDAAsD,SAAS;AAC/D;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA,yDAAyD,SAAS;AAClE,IAAI;AACJ,sDAAsD,SAAS;AAC/D;AACA;;;AC9Fa;;AAEE;AACf;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3HY;;AAEZ;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACe;AACf;AACA;;;ACTY;AACZ,CAAyC;AACU;;AAEnD;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA,2BAA2B,IAAI,GAAG,IAAI;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,qBAAqB,YAAY;AACjC,qBAAqB,YAAY;AACjC;AACA;;AAEA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7EY;;AAEZ;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AClCY;AACZ,CAA0D;;AAE1D;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA,WAAW;AACX;AACA;AACA,sCAAsC,IAAI,GAAG,IAAI;AACjD;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjGa;;AAEb;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9EY;AACZ,CAAmE;;AAEnE;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP,oBAAoB,kBAAkB;AACtC,gCAAgC,QAAQ;AACxC;;;ACba;AACb;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA,kBAAkB,QAAQ;AAC1B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;;ACvGa;;AAEb;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;;AC3Ca;AACb;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;;AC1Ca;AAOa;AACQ;AACK;AACF;AACqB;AACoB;AAK7C;AAC6B;;AAE9D;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,EAAE,gBAAgB;AAClB,EAAE,eAAe;AACjB,EAAE,aAAa;AACf;;AAEA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE,YAAY;;AAEd;AACA,8BAA8B,iBAAiB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,WAAW;;AAEpC,IAAI,YAAY;;AAEhB,gCAAgC,iBAAiB;AACjD,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,EAAE,iBAAiB;AACnB,EAAE,gBAAgB;AAClB,mBAAmB,MAAM;AACzB,0BAA0B,WAAW;AACrC,iBAAiB,QAAQ,KAAK,MAAM;AACpC,4BAA4B,WAAW;AACvC,4BAA4B,uBAAuB;;AAEnD;AACA;AACA,EAAE,WAAW;;AAEb,EAAE,iBAAiB;AACnB,EAAE,iBAAiB;;AAEnB;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA,eAAe,MAAM;AACrB,0BAA0B,WAAW;AACrC,aAAa,QAAQ,KAAK,MAAM;AAChC,4BAA4B,WAAW;;AAEvC,EAAE,eAAe;AACjB,EAAE,gBAAgB;AAClB;AACA;AACA;AACA;AACA,EAAE,eAAe;AACjB,EAAE,eAAe;AACjB;AACA,EAAE,WAAW;;AAEb,EAAE,iBAAiB;AACnB,EAAE,iBAAiB;;AAEnB,4BAA4B,uBAAuB;AACnD;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;;ACtKsB;AAC0B;AACsB;;AAEtE,iBAAiB,CAAC,cAAc","sources":["webpack://template-repo/./src/utilities/dom.js","webpack://template-repo/./src/modules/board.js","webpack://template-repo/./src/utilities/random-int.js","webpack://template-repo/./src/modules/player.js","webpack://template-repo/./src/utilities/get-cells.js","webpack://template-repo/./src/modules/ai-player.js","webpack://template-repo/./src/modules/ship.js","webpack://template-repo/./src/modules/dom/render-ships.js","webpack://template-repo/./src/modules/dom/screen/game-screen.js","webpack://template-repo/./src/modules/dom/screen/end-screen.js","webpack://template-repo/./src/modules/dom/screen/start-screen.js","webpack://template-repo/./src/modules/game.js","webpack://template-repo/./src/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Retrieves a DOM element within a grid-like structure based on specified row and column attributes.\n * @param {string|number} playerID - The ID of the player associated with the grid.\n * @param {string|number} row - The value of the `data-row` attribute of the desired grid cell.\n * @param {string|number} col - The value of the `data-col` attribute of the desired grid cell.\n * @returns {Element|null} The DOM element that matches the specified row and column attributes within the grid structure, or `null` if no matching element is found.\n */\nexport function getGridCell(playerID, row, col) {\n  return document.querySelector(\n    `[data-playerID=\"${playerID}\"][data-row=\"${row}\"][data-col=\"${col}\"]`\n  );\n}\n\n/**\n * Retrieves DOM elements representing ships on the gameboard for a given player.\n * @param {string} playerID - The ID of the player whose gameboard's ship DOM elements are to be retrieved.\n * @param {Player} player - The player whose gameboard's ship DOM elements are to be retrieved.\n * @returns {Element[]} An array of DOM elements representing the ships on the player's gameboard.\n */\nexport function getShipDOMElements(playerID, player) {\n  let shipDOMElements = [];\n  const shipsCoordinates = player.gameboard.shipsCoordinates;\n  for (let coordinate of shipsCoordinates) {\n    let [row, col] = coordinate;\n    shipDOMElements.push(getGridCell(playerID, row, col));\n  }\n\n  return shipDOMElements;\n}\n\n/**\n * Retrieves all DOM elements representing gameboard cells associated with a specific player.\n * These cells are identified by the specified playerID attribute.\n * @param {string} playerID - The ID of the player whose gameboard cells are to be retrieved.\n * @returns {NodeList} A NodeList containing all DOM elements that match the specified playerID attribute.\n */\nexport function getAllDOMGameboardCells(playerID) {\n  return document.querySelectorAll(`[data-playerID=\"${playerID}\"]`);\n}\n\n/**\n * Adds a CSS class to a specified HTML element.\n * @param {Element} element - The HTML element to which the class will be added.\n * @param {string} className - The name of the CSS class to be added.\n */\nexport function setClass(element, className) {\n  element.classList.add(className);\n}\n\nexport function removeClass(element) {\n  element.className = '';\n}\n\nexport function resetGridRender(playerID) {\n  const cells = getAllDOMGameboardCells(playerID);\n  cells.forEach((cell) => cell.classList.remove('shot--hit', 'shot--miss'));\n}\n\n/**\n * Renders the result of an attack on a game board cell.\n * Depending on the attack result, applies a corresponding CSS class to the cell.\n * @param {HTMLElement} cell - The DOM element representing the game board cell.\n * @param {string} attackResult - The result of the attack: \"hit\" for a successful hit, \"miss\" for a miss, \"illegal\" if the attack is illegal.\n */\nexport function renderAttack(cell, attackResult) {\n  switch (attackResult) {\n    case 'illegal':\n      return;\n    case 'hit':\n      setClass(cell, 'shot--hit');\n      break;\n    case 'miss':\n      setClass(cell, 'shot--miss');\n      break;\n  }\n}\n\n/**\n * Displays the number of ships left for a given player.\n * @param {Player} player - The player whose ship count is to be displayed.\n * @returns {void}\n */\nexport function displayNumOfShips(player) {\n  const humanPlayerShipsDisplay = document.body.querySelector('.player__ships');\n  const computerShipsDisplay = document.body.querySelector('.computer__ships');\n  let shipsNum = player.gameboard.getShipsLeft();\n\n  if (player.getName() === 'Human Player') {\n    humanPlayerShipsDisplay.textContent = `Ships left: ${shipsNum}`;\n  } else {\n    computerShipsDisplay.textContent = `Ships left: ${shipsNum}`;\n  }\n}\n","'use strict';\n\nexport default function GameBoard() {\n  const boardSize = 10; \n  const board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0));\n  const missedShots = new Set();\n  const ships = [];\n  const shipsCoordinates = [];\n  let shipsLeft = 4;\n  \n  /**\n   * Places a ship on the game board at the specified row and column.\n   * @param {Object} ship - The ship object to be placed on the board.\n   * @param {number} row - The row index where the ship will be placed.\n   * @param {number} col - The column index where the ship will be placed.\n   */\n  const placeShip = (ship, row, col) => {\n    // check if provided coordinates are legal\n    if (!isLegal(ship, row, col)) return false;\n\n    for (let i = 0; i < ship.getLength(); i++) {\n      if (ship.getOrientation() === \"horizontal\") {\n        shipsCoordinates.push([row, col])\n        board[row][col++] = ship.getLength();\n      } else {\n        shipsCoordinates.push([row, col])\n        board[row++][col] = ship.getLength();\n      }\n    }\n    ships.push(ship);\n    return true;\n  }\n\n  /**\n   * Retrieves the current state of the game board.\n   * @returns {Array} The current game board.\n   */\n  const getBoard = () => board;\n\n  /**\n   * Checks if placing a ship at the specified row and column is legal.\n   * @param {Object} ship - The ship object to be placed on the board.\n   * @param {number} row - The row index to check for legality.\n   * @param {number} col - The column index to check for legality.\n   * @returns {boolean} True if placing the ship is legal, otherwise false.\n   */\n  const isLegal = (ship, row, col) => {\n    if (ship.getOrientation() === \"horizontal\") {\n      // Check if there is enough space horizontally to place the ship\n      if (!(ship.getLength() + col <= board[row].length)) return false;\n  \n      for (let i = 0; i < ship.getLength(); i++) {\n        // Check if the coordinates in the path aren't already occupied\n        if (board[row][col++] !== 0) return false;\n      }\n      return true;\n    } \n    \n    if (ship.getOrientation() === \"vertical\") {\n      // Check if there is enough space vertically to place the ship\n      if (!(ship.getLength() + row <= board.length)) return false;\n  \n      for (let i = 0; i < ship.getLength(); i++) {\n        // Check if the coordinates in the path aren't already occupied\n        if (board[row++][col] !== 0) return false;\n      }\n      return true;\n    } \n  }\n  \n\n  /**\n   * Handles receiving an attack on the game board.\n   * @param {number} row - The row index of the attack.\n   * @param {number} col - The column index of the attack.\n   * @returns {boolean} - True if the attack hits a ship, false otherwise.\n   */\n  const receiveAttack = (row, col) => {\n    if (board[row][col] === 0) {\n      missedShots.add([row,col]);\n      return false;\n    }\n    \n    const shipId = board[row][col];\n    for (let ship of ships) {\n      let shipIndex = 0;\n      if (ship.getLength() === shipId) {\n        ship.hit();\n        if (ship.isSunk()) {\n          shipsLeft--;\n        }\n      }\n      shipIndex++;\n    }\n    board[row][col] = 0;\n    return true;\n  }\n\n  /**\n   * Retrieves the set of missed shots on the game board.\n   * @returns {Set} - The set containing the coordinates of missed shots.\n   */\n\n  /**\n   * Checks if all ships on the game board are sunk.\n   * @returns {boolean} - True if all ships are sunk, false otherwise.\n   */\n  const allShipsSunk = () => {\n    return shipsLeft === 0;\n  }\n\n  const getShipsLeft = () => shipsLeft;\n  \n  return {\n    ships,\n    placeShip,\n    shipsCoordinates,\n    getBoard,\n    isLegal,\n    receiveAttack, \n    getShipsLeft,\n    allShipsSunk,\n  }\n}\n\n","'use strict'\n\n/**\n * Generates a random integer between 0 (inclusive) and the specified maximum value (exclusive).\n * @param {number} max - The maximum value for the generated random integer.\n * @returns {number} A random integer between 0 and (max - 1).\n */\nexport default function getRandomInt(max) {\n  return Math.floor(Math.random() * max);\n}\n","'use strict'\nimport Gameboard from '../modules/board';\nimport getRandomInt from '../utilities/random-int';\n\n/**\n * Represents a player in the game.\n * @constructor\n * @param {string} playerName - The name of the player. \n * @returns {Object} An object representing a player.\n */\nexport function Player(playerName) {\n  const gameboard = new Gameboard();\n  const name = playerName;\n  const usedCoordinates = new Set();\n\n  /**\n   * Attacks the enemy player's game board at the specified row and column.\n   * If the attack is successful, marks the coordinates as used and returns \"hit\".\n   * If the attack is unsuccessful or if the coordinates are already used, returns \"miss\".\n   * @param {Object} enemyPlayer - The enemy player object.\n   * @param {number} row - The row index of the attack.\n   * @param {number} col - The column index of the attack.\n   * @return {string} \"hit\" if the attack is successful, \"miss\" if unsuccessful or coordinates are already used, \"illegal\" if the attack is not allowed.\n   */\n  function attack(enemyPlayer, row, col) {\n    const coordinates = `${row},${col}`;\n  \n    if (usedCoordinates.has(coordinates)) return 'illegal';\n    const attackResult = enemyPlayer.gameboard.receiveAttack(row, col);\n\n    usedCoordinates.add(coordinates);\n    return attackResult ? 'hit' : 'miss';\n   };\n\n   /**\n   * Returns the name of the player.\n   * @return {string} name - The name of the player.\n   */\n   const getName = () => name;  \n \n  /**\n   * Generates random attack coordinates.\n   * @returns {Array} An array containing the row and column indices of the attack.\n   */\n  const getRandomCoordinates = () => {\n    let coordinates = [];\n    coordinates.push(getRandomInt(10));\n    coordinates.push(getRandomInt(10));\n    return coordinates;\n  } \n\n  /**\n   * Randomly places ships on the game board.\n   * @param {Object[]} ships - An array of ship objects to be placed on the board.\n   */\n  const placeShipRandomly = (ships) => {\n    let [row, col] = getRandomCoordinates();\n      \n    for (let ship in ships) {\n      ship = ships[ship]\n\n      while (!gameboard.isLegal(ship, row, col)) {\n        if (Math.random() >= 0.5) ship.switchOrientation();\n        [row, col] = getRandomCoordinates();\n      }\n      gameboard.placeShip(ship, row, col)\n    }\n  };\n\n   return {\n    gameboard,\n    usedCoordinates,\n    attack,\n    getName,\n    placeShipRandomly,\n    getRandomCoordinates\n   }\n}\n","'use strict'\n\n/**\n * Returns an array of adjacent grid cells that have not been attacked.\n * @param {Object} player - The player object representing the AI player.\n * @param {number} row - The row index of the current cell.\n * @param {number} col - The column index of the current cell.\n * @returns {Array} An array of adjacent grid cells that have not been attacked.\n */\nexport function getAdjacentCells(player, row, col) {\n  const board = player.gameboard.getBoard();\n  const usedCoordinates = player.usedCoordinates;\n  const adjacentCells = [];\n  const top = row - 1;\n  const bottom = row + 1;\n  const left = col - 1;\n  const right = col + 1;\n  \n  if (top >= 0 && !usedCoordinates.has([top, col])) {\n    adjacentCells.push([top, col])\n  }; \n\n  if (bottom < board.length && !usedCoordinates.has([bottom, col])) {\n    adjacentCells.push([bottom, col]);\n  } \n\n  if (left >= 0 && !usedCoordinates.has([row, left])) {\n    adjacentCells.push([row, left]);\n  } \n\n  if (right < board[row].length && !usedCoordinates.has([row, right])) {\n    adjacentCells.push([row, right]);\n  } \n  return adjacentCells;\n}\n\n","'use strict'\nimport { getAdjacentCells } from '../utilities/get-cells';\n\n/**\n * Represents an AI player in the game.\n * @param {Object} player - The player object representing the AI player.\n * @returns {Object} An object representing an AI player.\n */\nexport function AIPlayer(player) {\n  const gameboard = player.gameboard;\n  let adjacentCells = [];\n\n  /**\n  * Generates random attack coordinates that have not been used before.\n  * @returns {string} A string representing the random attack coordinates.\n  */\n  const generateRandomAttackCoordinates = () => {\n    let coordinates = player.getRandomCoordinates();\n\n    while (player.usedCoordinates.has(coordinates)) {\n      coordinates = player.getRandomCoordinates()\n    }\n    return coordinates;\n  }\n\n  /**\n   * Attacks the enemy player's game board strategically.\n   * This method utilizes a mix of Breadth-First Search (BFS) and Depth-First Search (DFS) principles.\n   * BFS is used to prioritize unexplored areas by selecting adjacent cells to attack.\n   * DFS is used to continue the attack until a legal move is made or there are no more cells left to explore.\n   * @param {Object} enemyPlayer - The enemy player object.\n   * @returns {Promise} A promise that resolves with the attack result and coordinates of the attack.\n   */  \n  const attack = (enemyPlayer) => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        let [row, col] = generateRandomAttackCoordinates();\n        let attackResult;\n        \n        if (adjacentCells.length > 0) {\n          [row, col] = adjacentCells.pop();\n          attackResult = player.attack(enemyPlayer, row, col);\n\n          // continue attacking adjacent cells until a legal attack is made or there are no cells left\n          while (attackResult === 'illegal' && adjacentCells.length > 0) {\n            [row, col] = adjacentCells.pop();\n            attackResult = player.attack(enemyPlayer, row, col);\n          }\n        } else {\n          attackResult = player.attack(enemyPlayer, row, col);\n\n          while (attackResult === 'illegal') {\n            [row, col] = generateRandomAttackCoordinates();\n            attackResult = player.attack(enemyPlayer, row, col);\n          }\n        }\n        \n        // if the attack is a hit, find adjacent cells to continue the attack\n        if (attackResult === 'hit') {\n          getAdjacentCells(enemyPlayer, row, col).forEach((coordinates) => {\n           adjacentCells.push(coordinates); \n          });\n        }\n        \n        player.usedCoordinates.add(`${row},${col}`);\n        resolve([attackResult, row, col]);\n      }, 250);\n    });\n  }\n\n  /**\n   * Randomly places ships on the game board.\n   * @param {Object[]} ships - An array of ship objects to be placed on the board.\n   */\n  const placeShipRandomly = (ships) => {\n    let [row, col] = player.getRandomCoordinates();\n      \n    for (let ship in ships) {\n      ship = ships[ship]\n      // Continue until legal position on the ship is found\n      while (!gameboard.isLegal(ship, row, col)) {\n        // Randomly change the orientation of the ship\n        if (Math.random() >= 0.5) ship.switchOrientation();\n        // Get new random coordinates\n        [row, col] = player.getRandomCoordinates();\n      }\n      player.gameboard.placeShip(ship, row, col)\n    }\n  };\n\n  const getName = () => player.getName();\n  return {\n    gameboard,\n    attack,\n    placeShipRandomly,\n    getName\n  }\n}\n\n","'use strict';\n\n/**\n * Creates a ship object with methods to manage its properties and state.\n * @param {string} shipName - The name of the ship.\n * @param {number} length - The length of the ship.\n * @returns {Object} A ship object with methods for setting length, getting length,\n *                   recording hits, counting hits, and determining if the ship is sunk.\n */ \nexport function Ship(shipName, length) {\n  const name = shipName;\n  let damage = 0;\n  let orientation = false;\n\n   /**\n   * switches the orientation of the ship.\n   */ \n  const switchOrientation = () => {\n    orientation = !orientation;\n  } \n   /**\n   *\n   * Retrieves the orientation of the ship.\n   * @returns {string} The orientation of the ship: \"vertical\" or \"horizontal\".\n   */\n  const getOrientation = () => {\n    if (orientation) return \"vertical\";   \n    return \"horizontal\";\n } \n\n  /**\n  * Retrieves the length of the ship.\n  * @returns {number} The length of the ship.\n  */\n  const getLength = () => length;\n\n  /**\n   * Retrieves the count of hits on the ship.\n   * @returns {number} The count of hits on the ship.\n   */\n  const hitCount = () => damage;\n\n  /**\n   * Records a hit on the ship.\n   */\n  const hit = () => ++damage;\n\n  /**\n   * Checks if the ship is sunk.\n   * @returns {boolean} True if the number of hits equals or exceeds the ship's length, otherwise false.\n   */\n  const isSunk = () => hitCount() >= getLength();\n\n  /**\n   * Retrieves the name of the ship.\n   * @returns {string} The name of the ship.\n   */\n  const getName = () => name;\n\n  return {\n    switchOrientation,\n    getOrientation,\n    getLength,\n    hit,\n    hitCount,\n    isSunk,\n    getName\n  };\n};\n\n\nexport function createShips() {\n  return {    \n    carrier: new Ship('Carrier', 5),\n    battleship: new Ship('Battleship', 4),\n    cruiser: new Ship('Cruiser', 3),\n    destroyer: new Ship('Destroyer', 2)\n  }\n};\n","'use strict'\nimport { setClass, getShipDOMElements } from \"../../utilities/dom\";\n\n/**\n * Rends the ships on the game board for both the player and the computer.\n * This function retrieves DOM elements representing the ships for each player,\n * applies the \"ship\" CSS class to each element, and renders them on the board.\n * @param {object} player - The player object containing ship information.\n * @param {object} computer - The computer object containing ship information.\n */\nexport function renderShips(playerID, playerObject) {\n  let DOMElements = getShipDOMElements(playerID, playerObject);\n  DOMElements.forEach((cell) => setClass(cell, \"ship\"))\n}\n","'use strict';\n/**\n * Creates the game screen containing player and computer boards along with ship displays.\n * @returns {void}\n */\nexport function createGameScreen() {\n  const mainScreen = document.createElement('div');\n  const playerScreen = document.createElement('div');\n  const playerName = document.createElement('p');\n  const playerShipDisplayContainer = document.createElement('div');\n  const playerBoardContainer = document.createElement('div');\n  const playerShipDisplayText = document.createElement('p');\n\n  const computerScreen = document.createElement('div');\n  const computerName = document.createElement('p');\n  const computerShipDisplayContainer = document.createElement('div');\n  const computerBoardContainer = document.createElement('div');\n  const computerShipDisplayText = document.createElement('p');\n\n  // Set class names for elements\n  mainScreen.className = 'screen--game';\n  playerScreen.className = 'player';\n  playerName.className = 'player__name';\n  playerShipDisplayContainer.className = 'ship-display';\n  playerBoardContainer.classList.add('player__board', 'player__board--player');\n  playerShipDisplayText.className = 'player__ships';\n\n  computerScreen.className = 'computer';\n  computerName.className = 'player__name';\n  computerShipDisplayContainer.className = 'ship-display';\n  computerBoardContainer.classList.add(\n    'player__board',\n    'player__board--computer'\n  );\n  computerShipDisplayText.className = 'computer__ships';\n\n  // Set text content for player and computer names\n  playerName.textContent = 'Human Player';\n  computerName.textContent = 'Computer';\n\n  // Append elements to their respective containers\n  playerScreen.appendChild(playerName);\n  playerScreen.appendChild(createBoard(playerBoardContainer, 'player'));\n  playerScreen.appendChild(\n    playerShipDisplayContainer.appendChild(playerShipDisplayText)\n  );\n\n  computerScreen.appendChild(computerName);\n  computerScreen.appendChild(createBoard(computerBoardContainer, 'computer'));\n  computerScreen.appendChild(\n    computerShipDisplayContainer.appendChild(computerShipDisplayText)\n  );\n\n  // Append player and computer screens to the main screen\n  mainScreen.appendChild(playerScreen);\n  mainScreen.appendChild(computerScreen);\n\n  // Append the main screen to the document body\n  document.body.appendChild(mainScreen);\n}\n\n/**\n * Creates a game board by generating grid cells and appending them to the specified parent element.\n * @param {HTMLElement} parent - The parent element to which the grid cells will be appended.\n * @param {string} playerID - The ID of the player for whom the board is being created.\n * @returns {HTMLElement} The parent element with grid cells appended.\n */\nfunction createBoard(parent, playerID) {\n  for (let i = 0; i < 10; i++) {\n    for (let j = 0; j < 10; j++) {\n      const child = document.createElement('div');\n      child.setAttribute('data-row', i);\n      child.setAttribute('data-col', j);\n      child.setAttribute('data-playerID', playerID);\n      child.className = 'cell';\n      parent.appendChild(child);\n    }\n  }\n  return parent;\n}\n\n/**\n * Hides the game screen by setting its display style to 'none'.\n * @returns {void}\n */\nexport function hideGameScreen() {\n  document.body.querySelector('.screen--game').style.display = 'none';\n}\n\n/**\n * Shows the game screen by setting its display style to 'grid'.\n * @returns {void}\n */\nexport function showGameScreen() {\n  document.body.querySelector('.screen--game').style.display = 'grid';\n}\n\n/**\n * Removes the game screen element from the document body.\n * @returns {void}\n */\nexport function removeGameScreen() {\n  document.body.querySelector('.screen--game').remove();\n}\n","'use strict';\n\n/**\n * Displays the winner of the game along with a restart button.\n * @param {Player} winner - The winner of the game.\n * @returns {void}\n */\nexport function createEndScreen(winner, eventHandler) {\n  const screen = document.createElement('div');\n  const message = document.createElement('p');\n  const restartBtn = document.createElement('button');\n\n  message.textContent = `${winner.getName()} won the game!`;\n  restartBtn.textContent = 'Play again!';\n  restartBtn.addEventListener('click', eventHandler);\n  screen.classList.add('screen', 'screen--end');\n  screen.appendChild(message);\n  screen.appendChild(restartBtn);\n  document.body.appendChild(screen);\n}\n\n/**\n * Displays the end screen by setting its display style to 'flex'.\n * @returns {void}\n */\nexport function showEndScreen() {\n  document.body.querySelector('.screen--end').style.display = 'flex';\n}\n\n/**\n * Hides the end screen by setting its display style to 'none'.\n * @returns {void}\n */\nexport function hideEndScreen() {\n  document.body.querySelector('.screen--end').style.display = 'none';\n}\n\n/**\n * Removes the end screen from the DOM.\n * @returns {void}\n */\nexport function removeEndScreen() {\n  document.body.querySelector('.screen--end').remove();\n}\n","'use strict';\n/**\n * Creates and displays the start screen for the game, allowing the user to start the game.\n * @param {Function} eventHandler - The event handler function to be called when the start button is clicked.\n * @returns {void}\n */\nexport function createStartScreen(eventHandler) {\n  const screen = document.createElement('div');\n  const message = document.createElement('p');\n  const startBtn = document.createElement('button');\n\n  message.textContent = 'BATTLESHIP';\n  startBtn.textContent = 'Start Game';\n  startBtn.addEventListener('click', eventHandler);\n  screen.classList.add('screen', 'screen--start');\n  screen.appendChild(message);\n  screen.appendChild(startBtn);\n  document.body.appendChild(screen);\n}\n\n/**\n * Displays the start screen by setting its display style to 'flex'.\n * @returns {void}\n */\nexport function showStartScreen() {\n  document.body.querySelector('.screen--start').style.display = 'flex';\n}\n\n/**\n * Hides the start screen by setting its display style to 'none'.\n * @returns {void}\n */\nexport function hideStartScreen() {\n  document.body.querySelector('.screen--start').style.display = 'none';\n}\n\n/**\n * Removes the start screen from the DOM.\n * @returns {void}\n */\nexport function removeStartScreen() {\n  document.body.querySelector('.screen--start').remove();\n}\n","'use strict';\nimport {\n  renderAttack,\n  getGridCell,\n  displayNumOfShips,\n  getAllDOMGameboardCells,\n  resetGridRender,\n} from '../utilities/dom';\nimport { Player } from './player';\nimport { AIPlayer } from './ai-player';\nimport { createShips } from './ship';\nimport { renderShips } from '../modules/dom/render-ships';\nimport { createGameScreen, removeGameScreen } from './dom/screen/game-screen';\nimport {\n  createEndScreen,\n  removeEndScreen,\n  showEndScreen,\n} from './dom/screen/end-screen';\nimport { removeStartScreen } from './dom/screen/start-screen';\n\n/**\n * Checks if there is a winner by looking at the boards of each player and\n * checking if all of its ships have been sunk\n * @param {object} player - The player object containing ships information.\n * @param {object} computer - The computer object containing ships information.\n * @return {object} Returns the object whose all ships in its gameboard have been\n *                  sunk, or null if all both of them has at least one ship in their\n *                  gameboards.\n */\nexport function getTheWinner(player, computer) {\n  if (player.gameboard.allShipsSunk()) return computer;\n  if (computer.gameboard.allShipsSunk()) return player;\n  return null;\n}\n\n/**\n * Handles the end of the game by removing the game screen, creating the end screen with the winner displayed, and showing the end screen.\n * @param {Player} winner - The winner of the game.\n * @returns {void}\n */\nfunction handleGameOver(winner) {\n  removeGameScreen();\n  createEndScreen(winner, resetGame);\n  showEndScreen();\n}\n\n/**\n * Handles an attack on the game board initiated by a player.\n * @param {HTMLElement} cell - The DOM element representing the target cell.\n * @param {Object} player - The player object initiating the attack.\n * @param {Object} computer - The opponent player object.\n */\nexport function handleAttack(cell, player, computer) {\n  let winner = getTheWinner(player, computer);\n  if (winner) {\n    handleGameOver(winner);\n    return;\n  }\n\n  let row = parseInt(cell.dataset.row);\n  let col = parseInt(cell.dataset.col);\n  const attackResult = player.attack(computer, row, col);\n\n  renderAttack(cell, attackResult);\n\n  if (attackResult === 'illegal') return;\n  if (attackResult === 'hit') displayNumOfShips(computer);\n\n  computer.attack(player).then((result) => {\n    winner = getTheWinner(player, computer);\n    if (winner) {\n      handleGameOver(winner);\n      return;\n    }\n\n    const [attackResult, attackedRow, attackedCol] = result;\n    const attackedCell = getGridCell('player', attackedRow, attackedCol);\n\n    renderAttack(attackedCell, attackResult);\n\n    if (attackResult === 'hit') displayNumOfShips(player);\n  });\n}\n\n/**\n * Initializes the game by creating player and computer objects, placing ships randomly,\n * rendering ships, updating ship counts, and adding event listeners for attacks.\n * @returns {void}\n */\nexport function initializeGame() {\n  removeStartScreen();\n  createGameScreen();\n  let player = new Player('Human Player');\n  const playerShips = new createShips();\n  let computer = AIPlayer(new Player('Computer'));\n  const computerShips = new createShips();\n  const computerGridCells = getAllDOMGameboardCells('computer');\n\n  player.placeShipRandomly(playerShips);\n  computer.placeShipRandomly(computerShips);\n  renderShips('player', player);\n\n  displayNumOfShips(player);\n  displayNumOfShips(computer);\n\n  computerGridCells.forEach((cell) =>\n    cell.addEventListener('click', attackHandler)\n  );\n\n  /**\n   * Handles an attack initiated by the player.\n   * @param {Event} event - The click event on the game board cell.\n   * @returns {void}\n   */\n  function attackHandler(event) {\n    console.log('called');\n    const cell = event.target;\n    handleAttack(cell, player, computer);\n  }\n}\n\n/**\n * Resets the game by deleting the current player and computer objects, instantiating new ones,\n * placing ships randomly, rendering ships, updating ship counts, adding event listeners for attacks,\n * and displaying the game screen.\n * @param {Player} player - The player object.\n * @param {Object} computer - The computer object.\n * @returns {void}\n */\nfunction resetGame(player, computer) {\n  player = null;\n  computer = null;\n\n  player = new Player('Human Player');\n  const playerShips = new createShips();\n  computer = AIPlayer(new Player('Computer'));\n  const computerShips = new createShips();\n\n  removeEndScreen();\n  createGameScreen();\n  \n  player.placeShipRandomly(playerShips);\n  computer.placeShipRandomly(computerShips);\n  \n  resetGridRender('player');\n  resetGridRender('computer');\n  \n  renderShips('player', player);\n\n  displayNumOfShips(player);\n  displayNumOfShips(computer);\n\n  const computerGridCells = getAllDOMGameboardCells('computer');\n  computerGridCells.forEach((cell) =>\n    cell.addEventListener('click', attackHandler)\n  );\n\n  /**\n   * Handles an attack initiated by the player.\n   * @param {Event} event - The click event on the game board cell.\n   * @returns {void}\n   */\n  function attackHandler(event) {\n    const cell = event.target;\n    handleAttack(cell, player, computer);\n  }\n}\n","import './styles.css';\nimport { initializeGame } from './modules/game';\nimport { createStartScreen } from './modules/dom/screen/start-screen';\n\ncreateStartScreen(initializeGame);\n"],"names":[],"sourceRoot":""}